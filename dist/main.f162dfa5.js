parcelRequire=function(e,r,t,n){var i,o="function"==typeof parcelRequire&&parcelRequire,u="function"==typeof require&&require;function f(t,n){if(!r[t]){if(!e[t]){var i="function"==typeof parcelRequire&&parcelRequire;if(!n&&i)return i(t,!0);if(o)return o(t,!0);if(u&&"string"==typeof t)return u(t);var c=new Error("Cannot find module '"+t+"'");throw c.code="MODULE_NOT_FOUND",c}p.resolve=function(r){return e[t][1][r]||r},p.cache={};var l=r[t]=new f.Module(t);e[t][0].call(l.exports,p,l,l.exports,this)}return r[t].exports;function p(e){return f(p.resolve(e))}}f.isParcelRequire=!0,f.Module=function(e){this.id=e,this.bundle=f,this.exports={}},f.modules=e,f.cache=r,f.parent=o,f.register=function(r,t){e[r]=[function(e,r){r.exports=t},{}]};for(var c=0;c<t.length;c++)try{f(t[c])}catch(e){i||(i=e)}if(t.length){var l=f(t[t.length-1]);"object"==typeof exports&&"undefined"!=typeof module?module.exports=l:"function"==typeof define&&define.amd?define(function(){return l}):n&&(this[n]=l)}if(parcelRequire=f,i)throw i;return f}({"epB2":[function(require,module,exports) {
function e(n){return(e="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(n)}function n(){"use strict";n=function(){return i};var t,i={},r=Object.prototype,a=r.hasOwnProperty,o=Object.defineProperty||function(e,n,t){e[n]=t.value},l="function"==typeof Symbol?Symbol:{},c=l.iterator||"@@iterator",u=l.asyncIterator||"@@asyncIterator",s=l.toStringTag||"@@toStringTag";function f(e,n,t){return Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}),e[n]}try{f({},"")}catch(t){f=function(e,n,t){return e[n]=t}}function _(e,n,t,i){var r=n&&n.prototype instanceof m?n:m,a=Object.create(r.prototype),l=new U(i||[]);return o(a,"_invoke",{value:C(e,t,l)}),a}function d(e,n,t){try{return{type:"normal",arg:e.call(n,t)}}catch(e){return{type:"throw",arg:e}}}i.wrap=_;var p="suspendedStart",y="suspendedYield",v="executing",x="completed",g={};function m(){}function h(){}function b(){}var P={};f(P,c,function(){return this});var j=Object.getPrototypeOf,E=j&&j(j(G([])));E&&E!==r&&a.call(E,c)&&(P=E);var w=b.prototype=m.prototype=Object.create(P);function B(e){["next","throw","return"].forEach(function(n){f(e,n,function(e){return this._invoke(n,e)})})}function S(n,t){function i(r,o,l,c){var u=d(n[r],n,o);if("throw"!==u.type){var s=u.arg,f=s.value;return f&&"object"==e(f)&&a.call(f,"__await")?t.resolve(f.__await).then(function(e){i("next",e,l,c)},function(e){i("throw",e,l,c)}):t.resolve(f).then(function(e){s.value=e,l(s)},function(e){return i("throw",e,l,c)})}c(u.arg)}var r;o(this,"_invoke",{value:function(e,n){function a(){return new t(function(t,r){i(e,n,t,r)})}return r=r?r.then(a,a):a()}})}function C(e,n,i){var r=p;return function(a,o){if(r===v)throw Error("Generator is already running");if(r===x){if("throw"===a)throw o;return{value:t,done:!0}}for(i.method=a,i.arg=o;;){var l=i.delegate;if(l){var c=N(l,i);if(c){if(c===g)continue;return c}}if("next"===i.method)i.sent=i._sent=i.arg;else if("throw"===i.method){if(r===p)throw r=x,i.arg;i.dispatchException(i.arg)}else"return"===i.method&&i.abrupt("return",i.arg);r=v;var u=d(e,n,i);if("normal"===u.type){if(r=i.done?x:y,u.arg===g)continue;return{value:u.arg,done:i.done}}"throw"===u.type&&(r=x,i.method="throw",i.arg=u.arg)}}}function N(e,n){var i=n.method,r=e.iterator[i];if(r===t)return n.delegate=null,"throw"===i&&e.iterator.return&&(n.method="return",n.arg=t,N(e,n),"throw"===n.method)||"return"!==i&&(n.method="throw",n.arg=new TypeError("The iterator does not provide a '"+i+"' method")),g;var a=d(r,e.iterator,n.arg);if("throw"===a.type)return n.method="throw",n.arg=a.arg,n.delegate=null,g;var o=a.arg;return o?o.done?(n[e.resultName]=o.value,n.next=e.nextLoc,"return"!==n.method&&(n.method="next",n.arg=t),n.delegate=null,g):o:(n.method="throw",n.arg=new TypeError("iterator result is not an object"),n.delegate=null,g)}function L(e){var n={tryLoc:e[0]};1 in e&&(n.catchLoc=e[1]),2 in e&&(n.finallyLoc=e[2],n.afterLoc=e[3]),this.tryEntries.push(n)}function T(e){var n=e.completion||{};n.type="normal",delete n.arg,e.completion=n}function U(e){this.tryEntries=[{tryLoc:"root"}],e.forEach(L,this),this.reset(!0)}function G(n){if(n||""===n){var i=n[c];if(i)return i.call(n);if("function"==typeof n.next)return n;if(!isNaN(n.length)){var r=-1,o=function e(){for(;++r<n.length;)if(a.call(n,r))return e.value=n[r],e.done=!1,e;return e.value=t,e.done=!0,e};return o.next=o}}throw new TypeError(e(n)+" is not iterable")}return h.prototype=b,o(w,"constructor",{value:b,configurable:!0}),o(b,"constructor",{value:h,configurable:!0}),h.displayName=f(b,s,"GeneratorFunction"),i.isGeneratorFunction=function(e){var n="function"==typeof e&&e.constructor;return!!n&&(n===h||"GeneratorFunction"===(n.displayName||n.name))},i.mark=function(e){return Object.setPrototypeOf?Object.setPrototypeOf(e,b):(e.__proto__=b,f(e,s,"GeneratorFunction")),e.prototype=Object.create(w),e},i.awrap=function(e){return{__await:e}},B(S.prototype),f(S.prototype,u,function(){return this}),i.AsyncIterator=S,i.async=function(e,n,t,r,a){void 0===a&&(a=Promise);var o=new S(_(e,n,t,r),a);return i.isGeneratorFunction(n)?o:o.next().then(function(e){return e.done?e.value:o.next()})},B(w),f(w,s,"Generator"),f(w,c,function(){return this}),f(w,"toString",function(){return"[object Generator]"}),i.keys=function(e){var n=Object(e),t=[];for(var i in n)t.push(i);return t.reverse(),function e(){for(;t.length;){var i=t.pop();if(i in n)return e.value=i,e.done=!1,e}return e.done=!0,e}},i.values=G,U.prototype={constructor:U,reset:function(e){if(this.prev=0,this.next=0,this.sent=this._sent=t,this.done=!1,this.delegate=null,this.method="next",this.arg=t,this.tryEntries.forEach(T),!e)for(var n in this)"t"===n.charAt(0)&&a.call(this,n)&&!isNaN(+n.slice(1))&&(this[n]=t)},stop:function(){this.done=!0;var e=this.tryEntries[0].completion;if("throw"===e.type)throw e.arg;return this.rval},dispatchException:function(e){if(this.done)throw e;var n=this;function i(i,r){return l.type="throw",l.arg=e,n.next=i,r&&(n.method="next",n.arg=t),!!r}for(var r=this.tryEntries.length-1;r>=0;--r){var o=this.tryEntries[r],l=o.completion;if("root"===o.tryLoc)return i("end");if(o.tryLoc<=this.prev){var c=a.call(o,"catchLoc"),u=a.call(o,"finallyLoc");if(c&&u){if(this.prev<o.catchLoc)return i(o.catchLoc,!0);if(this.prev<o.finallyLoc)return i(o.finallyLoc)}else if(c){if(this.prev<o.catchLoc)return i(o.catchLoc,!0)}else{if(!u)throw Error("try statement without catch or finally");if(this.prev<o.finallyLoc)return i(o.finallyLoc)}}}},abrupt:function(e,n){for(var t=this.tryEntries.length-1;t>=0;--t){var i=this.tryEntries[t];if(i.tryLoc<=this.prev&&a.call(i,"finallyLoc")&&this.prev<i.finallyLoc){var r=i;break}}r&&("break"===e||"continue"===e)&&r.tryLoc<=n&&n<=r.finallyLoc&&(r=null);var o=r?r.completion:{};return o.type=e,o.arg=n,r?(this.method="next",this.next=r.finallyLoc,g):this.complete(o)},complete:function(e,n){if("throw"===e.type)throw e.arg;return"break"===e.type||"continue"===e.type?this.next=e.arg:"return"===e.type?(this.rval=this.arg=e.arg,this.method="return",this.next="end"):"normal"===e.type&&n&&(this.next=n),g},finish:function(e){for(var n=this.tryEntries.length-1;n>=0;--n){var t=this.tryEntries[n];if(t.finallyLoc===e)return this.complete(t.completion,t.afterLoc),T(t),g}},catch:function(e){for(var n=this.tryEntries.length-1;n>=0;--n){var t=this.tryEntries[n];if(t.tryLoc===e){var i=t.completion;if("throw"===i.type){var r=i.arg;T(t)}return r}}throw Error("illegal catch attempt")},delegateYield:function(e,n,i){return this.delegate={iterator:G(e),resultName:n,nextLoc:i},"next"===this.method&&(this.arg=t),g}},i}function t(e,n,t,i,r,a,o){try{var l=e[a](o),c=l.value}catch(e){return void t(e)}l.done?n(c):Promise.resolve(c).then(i,r)}function i(e){return function(){var n=this,i=arguments;return new Promise(function(r,a){var o=e.apply(n,i);function l(e){t(o,r,a,l,c,"next",e)}function c(e){t(o,r,a,l,c,"throw",e)}l(void 0)})}}i(n().mark(function e(){var t,r,a,o,l,c,u,s,f,_,d,p,y,v,x,g,m,h,b,P,j,E,w,B,S,C,N,L,T,U,G,A,O,M,F,k,I,V,R,Y,W,z,q,X,D,H,Z,J,K,Q,$,ee,ne,te,ie,re,ae,oe,le,ce,ue,se,fe,_e,de,pe,ye,ve,xe,ge,me,he,be,Pe,je,Ee,we,Be,Se,Ce,Ne,Le,Te,Ue,Ge,Ae,Oe,Me,Fe,ke,Ie,Ve,Re,Ye,We,ze,qe,Xe,De,He,Ze,Je,Ke,Qe;return n().wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return Qe=function(e,n,t){return Math.min(Math.max(e,n),t)},Ke=function(e,n){return Math.random()*(n-e)+e},Je=function(){V=!1,R=0,Y=0,k=1,M=0,F=0,Re()},Ze=function(){void 0!==We&&(clearInterval(We),We=void 0),Ie((Ye=0)*ze/1e3,"s"),Fe(),console.log("Simulation reset complete.")},He=function(){void 0!==We&&(clearInterval(We),We=void 0),console.log("Simulation stopped.")},De=function(){void 0===We?We=setInterval(qe,ze):console.log("すでにスタートしています。")},Xe=function(){return(Xe=i(n().mark(function e(){var t,i,r;return n().wrap(function(e){for(;;)switch(e.prev=e.next){case 0:for(performance.now(),t=u.createCommandEncoder(),i=0;i<400;i++)t.clearBuffer(ye),t.clearBuffer(pe),(t=Oe(t)).copyBufferToBuffer(se,0,ue,0,j),t.copyBufferToBuffer(pe,0,de,0,N);t=Me(t),r=t.finish(),u.queue.submit([r]),performance.now(),Ie(Ye*ze/1e3,"s"),Ye++;case 9:case"end":return e.stop()}},e)}))).apply(this,arguments)},qe=function(){return Xe.apply(this,arguments)},Re=function(){u.queue.writeBuffer(ce,0,K());var e=u.createCommandEncoder(),n=(e=Me(e)).finish();u.queue.submit([n])},Ve=function(e){switch(e){case"id":I=0;break;case"vabs":I=1}Re()},Ie=function(e,n){ke.clearRect(0,0,z.width,z.height);ke.font="".concat(24,"px serif"),ke.fillStyle="white";var t=e.toFixed(2)+" "+n,i=ke.measureText(t).width,r=z.width-i-40;ke.fillText(t,r,44)},Fe=function(){u.queue.writeBuffer(ce,0,K()),u.queue.writeBuffer(ue,0,ee()),u.queue.writeBuffer(ve,0,ne()),u.queue.writeBuffer(xe,0,ne());var e=new Float32Array(new ArrayBuffer(G));u.queue.writeBuffer(fe,0,e);var n=new Uint32Array(new ArrayBuffer(A));u.queue.writeBuffer(_e,0,n);var t=new Uint32Array(new ArrayBuffer(N));u.queue.writeBuffer(de,0,t);var i=new Uint32Array(new ArrayBuffer(L));u.queue.writeBuffer(ye,0,i);var r=u.createCommandEncoder();(r=Oe(r)).copyBufferToBuffer(se,0,ue,0,j),r.copyBufferToBuffer(pe,0,de,0,N),r=Me(r),u.queue.submit([r.finish()])},Me=function(e){var n={colorAttachments:[{view:d.getCurrentTexture().createView(),loadOp:"clear",clearValue:{r:0,g:0,b:.4,a:1},storeOp:"store"}]},t=e.beginRenderPass(n);return t.setPipeline(Ce),t.setVertexBuffer(0,je),t.setBindGroup(0,Be),t.draw(Pe.length/2,P),t.setPipeline(Ae),t.setVertexBuffer(0,Ue),t.setBindGroup(0,Ge),t.draw(Te.length/2),t.end(),e},Oe=function(e){var n=Math.ceil(P/64),t=e.beginComputePass();return t.setPipeline(le),t.setBindGroup(0,ge),t.setBindGroup(1,me),t.dispatchWorkgroups(n),t.end(),e},be=function(e,n,t,i){for(var r=[],a=1;a<i;a++){var o=a/i*2*Math.PI,l=(a+1)/i*2*Math.PI,c=e+t*Math.cos(o),u=n+t*Math.sin(o),s=e+t*Math.cos(l),f=n+t*Math.sin(l);r.push(e,n,c,u,s,f)}return new Float32Array(r)},ie=function(e){throw document.body.innerHTML="<pre>".concat(e,"</pre>"),Error(e)},ne=function(){for(var e=new Float32Array(new ArrayBuffer(x)),n=0;n<y;n++)e[n*v+0]=w,e[n*v+1]=1,e[n*v+2]=g,e[n*v+3]=m,e[n*v+4]=h,e[n*v+5]=b,e[n*v+6]=0,e[n*v+7]=0,e[n*v+8]=90,e[n*v+9]=0;for(var t=W.checked,i=0;i<y;i++)e[i*v+1]=t?1:0;return e},ee=function(){return Q},K=function(){return new Float32Array([d.canvas.width,d.canvas.height,p,O,E,w,S,C,B,P,U,M,F,k,I])},r=function(e,n){return t.has(e)?parseFloat(t.get(e)):n},t=new URLSearchParams(location.search),"gpu"in navigator||ie("WebGPU not supported. Please enable it in about:flags in Chrome or in about:config in Firefox."),e.next=24,navigator.gpu.requestAdapter();case 24:return(a=e.sent)||ie("Couldn’t request WebGPU adapter."),o=a.limits,l=o.maxBufferSize,c=o.maxStorageBufferBindingSize,console.log("maxBufferSize= ",l),console.log("maxStorageBufferBindingSize= ",c),e.next=31,a.requestDevice({requiredLimits:{maxStorageBuffersPerShaderStage:10}});case 31:for((u=e.sent)||ie("Couldn’t request WebGPU device."),console.log("device limit= ",u.limits),s=document.getElementById("webgpuCanvas"),f=r("width",1e3),_=r("height",500),s.width=f,s.height=_,d=s.getContext("webgpu"),s.style.width=f+"px",s.style.height=_+"px",p=r("width_length",15),x=(y=1)*(v=10)*Float32Array.BYTES_PER_ELEMENT,g=r("x1",4),m=r("y1",0),h=r("x2",4),b=r("y2",6),P=r("balls",12e3),8,j=8*P*Float32Array.BYTES_PER_ELEMENT,E=Qe(r("min_radius",.01),.01,.1),w=Qe(r("max_radius",.02),E,.1),B=4*w+.001,S=Math.ceil(p/B),C=Math.pow(Math.ceil(B/(2*E)),2),N=S*Math.ceil(S*d.canvas.height/d.canvas.width)*C*Uint32Array.BYTES_PER_ELEMENT,L=S*Math.ceil(S*d.canvas.height/d.canvas.width)*Uint32Array.BYTES_PER_ELEMENT,T=2*Math.atan(E/Math.sqrt(Math.pow(E+w,2)-Math.pow(E,2))),U=Math.ceil(2*Math.PI/T),G=P*(U+4+y)*2*Float32Array.BYTES_PER_ELEMENT,A=P*U*Uint32Array.BYTES_PER_ELEMENT,O=30,M=0,F=0,k=1,I=0,s.style.cursor="grab",V=!1,R=0,Y=0,W=document.getElementById("enableLine"),z=document.getElementById("overlayCanvas"),q=document.getElementById("modeId"),X=document.getElementById("modeVabs"),D=document.getElementById("start"),H=document.getElementById("reset"),Z=document.getElementById("stop"),J=document.getElementById("reset_view"),Q=new Float32Array(new ArrayBuffer(j)),$=0;$<P;$++)Q[8*$+0]=Ke(E,w),Q[8*$+2]=w+$%(p/(2*w*4))*w*2,Q[8*$+3]=w+Math.floor($/(p/(2*w*4)))*w*2,Q[8*$+4]=0,Q[8*$+5]=0,Q[8*$+6]=0,Q[8*$+7]=0;console.log("最大接触粒子数= ",U),console.log("最小粒子半径= ",E),console.log("最大粒子半径= ",w),console.log("粒子数= ",P),console.log("Max buffer size= ",u.limits.maxBufferSize),te=navigator.gpu.getPreferredCanvasFormat(),d.configure({device:u,format:te}),re=u.createShaderModule({code:"\n    struct Ball {\n      radius: f32,\n      padding: f32,\n      position: vec2<f32>,\n      velocity: vec2<f32>,\n      angle: f32,\n      anguler_velocity: f32,\n    }\n\n    @group(0) @binding(0)\n    var<storage, read_write> input: array<Ball>;\n\n    @group(0) @binding(1)\n    var<storage, read_write> output: array<Ball>;\n\n    struct EF {\n      resilience_force: vec2<f32>,\n    }\n\n    @group(0) @binding(2)\n    var<storage, read_write> ef_input: array<EF>; // 復元力\n\n\n    struct Scene {\n      width: f32, // canvasの幅(pixel)\n      height: f32, // canvasの高さ(pixel)\n      L: f32, // canvasの幅(m)\n      fps: f32, // フレームレート\n      minRadius: f32, // 粒子の最小半径(m)\n      maxRadius: f32, // 粒子の最大半径(m)\n      nx: f32, // x方向の格子点数\n      grid_size: f32, // 1グリッドあたりの最大要素数\n      spacing: f32, // 格子間隔\n      numBalls: u32, // 粒子数\n      maxContactParticleNumber: f32, // 最大接触粒子数\n    }\n\n    @group(0) @binding(3)\n    var<uniform> scene: Scene;\n\n \n    @group(0) @binding(4)\n    var<storage, read_write> gl_input: array<u32>;\n\n    @group(0) @binding(5)\n    var<storage, read_write> gl_output: array<u32>;\n\n    @group(0) @binding(6)\n    var<storage, read_write> gl_atomic : array<atomic<u32>>;\n\n    @group(0) @binding(7)\n    var<storage, read_write> ef_index_input: array<u32>; // 復元力の相手粒子のインデックス\n\n\n    struct Line {\n      thickness: f32,\n      isValid: u32,\n      position_1: vec2<f32>,\n      position_2: vec2<f32>,\n      velocity: vec2<f32>,\n      angle: f32,\n      anguler_velocity: f32,\n    }\n\n    @group(1) @binding(0)\n    var<storage, read_write> line_input: array<Line>;\n\n    @group(1) @binding(1)\n    var<storage, read_write> line_output: array<Line>;\n\n\n\n    const PI: f32 = 3.14159;                        // 円周率\n    // const TIME_STEP: f32 = 0.0016;                   // 時間刻み(s)\n    const E: f32 = 70e+4;                           // ヤング率(kN/m2) 例:70e+9\n    const v: f32 = 0.35;                            // ポアソン比\n    const k_n: f32 = 9.0e+6; //PI*E*(1-v)/(4*(1+v)*(1-2*v));  // 法線方向ばね定数(kN/m)\n    const k_s: f32 = 3.0e+6; //PI*E/(8*(1+v));                // 接線方向ばね定数(kN/m)\n    const c: f32 = 0.0;                             // みかけの粘着力(kN/m2)\n    const fai: f32 = 30.0;                           // 摩擦角(°)\n    const g: f32 = -9.81;                           // 重力加速度(m/s2)\n    const rho: f32 = 2.5e+3;                        // 密度(kg/m3)\n    const e_n: f32 = 1.0;                           // 法線方向はね返り係数\n    const e_s: f32 = 1.0;                           // 接線方向はね返り係数\n    const h: f32 = 0.1;                           // 係数\n    const maxContactParticleNumber: u32 = ".concat(U,";      // 最大接触粒子数(配列の要素数を固定するためここで定義する)\n    const maxLineNumber: u32 = ").concat(y,"; // 最大線分数\n    \n\n    // eta(粘性係数)を求める(対粒子)\n    fn calculationEta(m_i: f32, m_j: f32) -> vec2<f32> {\n      let m_ij = 2* m_i * m_j / (m_i + m_j);\n      // let eta_n = -2*log(e_n)*sqrt( ( m_ij * k_n ) / ( pow(PI, 2) + pow(log(e_n), 2) ) );\n      // let eta_s = -2*log(e_s)*sqrt( ( m_ij * k_s ) / ( pow(PI, 2) + pow(log(e_s), 2) ) );\n      let eta_n = h*2*sqrt(m_ij*k_n);\n      let eta_s = h*2*sqrt(m_ij*k_s);\n      return vec2<f32>(2.0e+3, 1.0e+3); //vec2<f32>(eta_n, eta_s);\n    }\n\n    // eta(粘性係数)を求める(対壁)\n    fn calculationEtaWithWall(m_i: f32) -> vec2<f32> {\n      let m_ij = m_i;\n      // let eta_n = -2*log(e_n)*sqrt( ( m_ij * k_n ) / ( pow(PI, 2) + pow(log(e_n), 2) ) );\n      // let eta_s = -2*log(e_s)*sqrt( ( m_ij * k_s ) / ( pow(PI, 2) + pow(log(e_s), 2) ) );\n      let eta_n = h*2*sqrt(m_ij*k_n);\n      let eta_s = h*2*sqrt(m_ij*k_s);\n      return vec2<f32>(2.0e+3, 1.0e+3); //vec2<f32>(eta_n, eta_s);\n    }\n\n    // 衝突後の粒子同士の相対速度を求める\n    fn calculationVelocityAfterCollision(position_i: vec2<f32>, velocity_i: vec2<f32>, anguler_velocity_i: f32, radius_i: f32, position_j: vec2<f32>, velocity_j: vec2<f32>, anguler_velocity_j: f32, radius_j: f32) -> vec2<f32> {\n      let lx = position_j.x - position_i.x;\n      let ly = position_j.y - position_i.y;\n      let ld = sqrt(lx * lx + ly * ly);\n      let cos_a_ji = lx/ld;\n      let sin_a_ji = ly/ld;\n      let u_ji_n =  (velocity_i.x - velocity_j.x) * cos_a_ji + (velocity_i.y - velocity_j.y) * sin_a_ji;\n      let u_ji_s = -(velocity_i.x - velocity_j.x) * sin_a_ji + (velocity_i.y - velocity_j.y) * cos_a_ji + radius_i * anguler_velocity_i + radius_j * anguler_velocity_j;\n      return vec2<f32>(u_ji_n, u_ji_s);\n    }\n\n    // 衝突後の粒子同士の相対速度を求める(対壁)\n    fn calculationVelocityAfterCollisionWithWall(velocity_i: vec2<f32>, anguler_velocity_i: f32, radius_i: f32, alpha: f32) -> vec2<f32> {\n      let cos_a_ji = cos(radians(alpha));\n      let sin_a_ji = sin(radians(alpha));\n      let u_ji_n =  (velocity_i.x) * cos_a_ji + (velocity_i.y) * sin_a_ji;\n      let u_ji_s = -(velocity_i.x) * sin_a_ji + (velocity_i.y) * cos_a_ji + radius_i * anguler_velocity_i;\n      return vec2<f32>(u_ji_n, u_ji_s);\n    }\n\n    // 衝突後の粒子同士の相対速度を求める(対線分)\n    fn calculationVelocityAfterCollisionWithStackLine(position_i: vec2<f32>, velocity_i: vec2<f32>, anguler_velocity_i: f32, radius_i: f32, position_j: vec2<f32>, velocity_j: vec2<f32>, anguler_velocity_j: f32, radius_j: f32) -> vec2<f32> {\n      let lx = position_j.x - position_i.x;\n      let ly = position_j.y - position_i.y;\n      let ld = sqrt(lx * lx + ly * ly);\n      let cos_a_ji = lx/ld;\n      let sin_a_ji = ly/ld;\n      let u_ji_n =  (velocity_i.x - velocity_j.x) * cos_a_ji + (velocity_i.y - velocity_j.y) * sin_a_ji;\n      let u_ji_s = -(velocity_i.x - velocity_j.x) * sin_a_ji + (velocity_i.y - velocity_j.y) * cos_a_ji + radius_i * anguler_velocity_i + radius_j * anguler_velocity_j;\n      return vec2<f32>(u_ji_n, u_ji_s);\n    }\n\n\n    // 復元力を求める(x,yはn,s)\n    fn calculationRestoringForceNS(resilience_force: vec2<f32>, u_ji: vec2<f32>, k_n: f32, k_s: f32, timeStep: f32) -> vec2<f32> {\n      return vec2<f32>(resilience_force.x + k_n * u_ji.x * timeStep, resilience_force.y + k_s * u_ji.y * timeStep);\n    }\n\n\n    // 粘性力を求める(x,yはn,s)\n    fn calculationViscousForceNS(eta_n: f32, eta_s: f32, u_ji_n: f32, u_ji_s: f32) -> vec2<f32> {\n      return vec2<f32>(eta_n*u_ji_n, eta_s*u_ji_s);\n    }\n\n\n    // 弾性力を求める(x,yはn,s)\n    fn calculationElasticForceNS(resilience_force: vec2<f32>, viscous_force: vec2<f32>) -> vec2<f32> {\n      // 法線方向\n      var f_ji_n: f32;\n      if(resilience_force.x >= 0){\n        f_ji_n = resilience_force.x + viscous_force.x;\n      }else{\n        f_ji_n = 0.0;\n      }\n      // 接線方向(個別要素法による粒状体の力学的挙動に関する解析的研究(その1)より)\n      var f_ji_s: f32;\n      if(resilience_force.x < 0){\n        f_ji_s = 0.0;\n      }else if(abs(resilience_force.y) > tan(radians(fai))*resilience_force.x + c){\n        f_ji_s = (tan(radians(fai))*resilience_force.x + c)*sign(resilience_force.y);\n      }else{\n        f_ji_s = resilience_force.y + viscous_force.y;\n      }\n      return vec2<f32>(f_ji_n, f_ji_s);\n    }\n\n    // 弾性力をxy成分に分解する(引数のx,yはn,s)\n    fn calculationElasticForceXY(f_ji: vec2<f32>, position_i: vec2<f32>, position_j: vec2<f32>) -> vec2<f32> {\n      let lx = position_j.x - position_i.x;\n      let ly = position_j.y - position_i.y;\n      let ld = sqrt(lx * lx + ly * ly);\n      let cos_a_ji = lx/ld;\n      let sin_a_ji = ly/ld;\n      let f_ji_x = -f_ji.x * cos_a_ji + f_ji.y * sin_a_ji;\n      let f_ji_y = -f_ji.x * sin_a_ji - f_ji.y * cos_a_ji;\n      return vec2<f32>(f_ji_x, f_ji_y);\n    }\n\n    // 弾性力をxy成分に分解する(対壁)\n    fn calculationElasticForceXYWithWall(f_ji: vec2<f32>, alpha: f32) -> vec2<f32> {\n      let cos_a_ji = cos(radians(alpha));\n      let sin_a_ji = sin(radians(alpha));\n      let f_ji_x = -f_ji.x * cos_a_ji + f_ji.y * sin_a_ji;\n      let f_ji_y = -f_ji.x * sin_a_ji - f_ji.y * cos_a_ji;\n      return vec2<f32>(f_ji_x, f_ji_y);\n    }\n\n    // 粒子の加速度を求める\n    fn calculationAcceleration(m_i: f32, F_i: f32, G_i: f32) -> vec2<f32> {\n      return vec2<f32>(F_i/m_i, G_i/m_i + g);\n    }\n\n    // 粒子の速度を求める\n    fn calculationVelocity(velocity: vec2<f32>, acceleration: vec2<f32>, timeStep: f32) -> vec2<f32> {\n      return vec2<f32>(velocity.x + acceleration.x * timeStep, velocity.y + acceleration.y * timeStep);\n    }\n\n    // 粒子の位置を求める\n    fn calculationPosition(position: vec2<f32>, velocity: vec2<f32>, timeStep: f32) -> vec2<f32> {\n      return vec2<f32>(position.x + velocity.x * timeStep, position.y + velocity.y * timeStep);\n    }\n\n    // 粒子の角加速度を求める\n    fn calculationAngularAcceleration(I_i: f32, T_i: f32) -> f32 {\n      return f32(T_i/I_i);\n    }\n\n    // 粒子の角速度を求める\n    fn calculationAngularVelocity(angular_velocity: f32, angular_acceleration: f32, timeStep: f32) -> f32 {\n      return f32(angular_velocity + angular_acceleration * timeStep);\n    }\n\n    // 粒子の角度を求める\n    fn calculationAngle(angle: f32, angular_velocity: f32, timeStep: f32) -> f32 {\n      return f32(angle + angular_velocity * timeStep);\n    }\n\n    // 粒子と線分の接触判定用\n    // 接触判定のためのベクトルACを算出する\n    fn calVectorAC(line: Line, position: vec2<f32>) -> vec2<f32>{\n      return position - line.position_1;\n    }\n\n    // t'を算出する\n    fn calTDash(line: Line, AC:vec2<f32>) -> f32 {\n      // 線分ABのベクトル\n      let AB = line.position_2 - line.position_1;\n      // tを算出((w・v)/(v・v))=((AC・AB)/(AB・AB))\n      let t = dot(AC,AB)/dot(AB,AB);\n      // tを0と1の間に限定する\n      return clamp(t, 0, 1);\n    }\n\n    // 接触判定のためのベクトルAD(接触点)を算出する\n    fn calVectorD(line: Line, tdash: f32) -> vec2<f32>{\n      // 線分ABのベクトル\n      let AB = line.position_2 - line.position_1;\n      return vec2<f32>(line.position_1.x + tdash * AB.x, line.position_1.y + tdash * AB.y);\n    }\n\n\n    // 左下のマスのインデックス(インデックス要素数は抜きにして考える)(0より小さい時のことはあとで考える)\n    fn cal_1_1_index(nx: u32, i: u32) -> i32 {\n      return i32(i-nx-1);\n    }\n    // 真下のマスのインデックス(インデックス要素数は抜きにして考える)(0より小さい時のことはあとで考える)\n    fn cal_2_1_index(nx: u32, i: u32) -> i32 {\n      return i32(i-nx);\n    }\n    // 右下のマスのインデックス(インデックス要素数は抜きにして考える)(0より小さい時のことはあとで考える)\n    fn cal_3_1_index(nx: u32, i: u32) -> i32 {\n      return i32(i-nx+1);\n    }\n    // 左のマスのインデックス(インデックス要素数は抜きにして考える)(0より小さい時のことはあとで考える)\n    fn cal_1_2_index(nx: u32, i: u32) -> i32 {\n      return i32(i-1);\n    }\n    // 真ん中のマスのインデックス(インデックス要素数は抜きにして考える)(0より小さい時のことはあとで考える)\n    fn cal_2_2_index(nx: u32, i: u32) -> i32 {\n      return i32(i);\n    }\n    // 右のマスのインデックス(インデックス要素数は抜きにして考える)(超えた時のことはあとで考える)\n    fn cal_3_2_index(nx: u32, i: u32) -> i32 {\n      return i32(i+1);\n    }\n    // 左上のマスのインデックス(インデックス要素数は抜きにして考える)(超えた時のことはあとで考える)\n    fn cal_1_3_index(nx: u32, i: u32) -> i32 {\n      return i32(i+nx-1);\n    }\n    // 真上のマスのインデックス(インデックス要素数は抜きにして考える)(超えた時のことはあとで考える)\n    fn cal_2_3_index(nx: u32, i: u32) -> i32 {\n      return i32(i+nx);\n    }\n    // 右上のマスのインデックス(インデックス要素数は抜きにして考える)(超えた時のことはあとで考える)\n    fn cal_3_3_index(nx: u32, i: u32) -> i32 {\n      return i32(i+nx+1);\n    }\n\n    fn calculationOtherBallIndexArray(nx: u32, i: u32) -> array<i32, 9> {\n      var other_index_array: array<i32, 9>; // 判定を行う相手のインデックスを格納する配列(自分自身と周りの8マス=9マス)\n      other_index_array[0] = cal_1_1_index(nx, i);\n      other_index_array[1] = cal_2_1_index(nx, i);\n      other_index_array[2] = cal_3_1_index(nx, i);\n      other_index_array[3] = cal_1_2_index(nx, i);\n      other_index_array[4] = cal_2_2_index(nx, i);\n      other_index_array[5] = cal_3_2_index(nx, i);\n      other_index_array[6] = cal_1_3_index(nx, i);\n      other_index_array[7] = cal_2_3_index(nx, i);\n      other_index_array[8] = cal_3_3_index(nx, i);\n      return other_index_array;\n    }\n\n    @compute @workgroup_size(64)\n    fn main(\n      @builtin(global_invocation_id)\n      global_id : vec3<u32>,\n    ) {\n      let TIME_LOOP: u32 = 1;                   // 1fpsあたりのループ回数\n      let TIME_STEP: f32 = 1/scene.fps/400;   // 時間刻み(s)\n      let num_balls: u32 = arrayLength(&output);\n      // let num_lines: u32 = maxLineNumber;//arrayLength(&line_input);\n\n      let nx: u32 = u32(scene.nx); //u32(ceil(scene.L/scene.maxRadius)); // x方向の格子点数\n      let ny: u32 = u32(ceil(f32(nx) * scene.height/scene.width)); // y方向の格子点数\n      let spacing: f32 = scene.spacing; //scene.maxRadius*2+0.001; // 格子間隔\n      let grid_size: u32 = u32(scene.grid_size); //u32(ceil(scene.maxRadius/scene.minRadius)) * u32(ceil(scene.maxRadius/scene.minRadius)); // 1グリッドあたりの最大要素数\n\n\n\n      if(global_id.x >= num_balls) {\n        return;\n      }\n\n\n\n      var src_ball = input[global_id.x];\n      let dst_ball = &output[global_id.x];\n\n      (*dst_ball) = src_ball;\n\n      let src_gl_index:u32 = u32(floor(src_ball.position.y/spacing))*nx + u32(floor(src_ball.position.x/spacing)); // 今のインデックス要素数は抜きにして考える\n      let other_index_array: array<i32, 9> = calculationOtherBallIndexArray(nx, src_gl_index); // 判定を行う相手のインデックスの始まりを格納する配列(自分自身と周りの8マス=9マス)\n\n\n      // set const (奥行き1の円柱)\n      let m_i = pow(src_ball.radius, 2.0) * PI * rho;   // 粒子iの質量\n      let I_i = 0.5 * m_i * pow(src_ball.radius, 2.0);  // 粒子iの慣性モーメント\n\n\n      var F_i: f32 = 0.0;                               // 粒子iの弾性力の合力\n      var G_i: f32 = 0.0;                               // 粒子iのせん断力の合力\n      var T_i: f32 = 0.0;                               // 粒子iのトルクの合力\n\n\n      var ef_counter:u32 = 0; // 接触力の相手の数を保存しておく変数\n      var ef_output: array<EF, maxContactParticleNumber + 4 + maxLineNumber>; // 計算した接触力を保存する配列(+4は上下左右の壁)\n      var ef_index_output: array<u32, maxContactParticleNumber>; // 計算した接触粒子を保存する配列\n      for (var i = 0u; i < maxContactParticleNumber; i = i + 1u) {\n        ef_output[i].resilience_force = vec2<f32>(0.0, 0.0);\n        ef_index_output[i] = 0u;\n      }\n      ef_output[maxContactParticleNumber    ].resilience_force = vec2<f32>(0.0, 0.0);\n      ef_output[maxContactParticleNumber + 1].resilience_force = vec2<f32>(0.0, 0.0);\n      ef_output[maxContactParticleNumber + 2].resilience_force = vec2<f32>(0.0, 0.0);\n      ef_output[maxContactParticleNumber + 3].resilience_force = vec2<f32>(0.0, 0.0);\n      // 線分の数ループ\n      for (var i = 0u; i < maxLineNumber; i = i + 1u) {\n        ef_output[maxContactParticleNumber + 4 + i].resilience_force = vec2<f32>(0.0, 0.0);\n      }\n\n\n\n      // Ball/Ball collision\n      // マスごとにループ\n      for(var j = 0; j < 9; j++) {\n        // 格子点が存在しない場合はスキップ\n        if(other_index_array[j] < 0 || other_index_array[j] >= i32(nx)*i32(ny)) {\n          continue;\n        }\n        // gl_inputの対象インデックスのループ\n        for(var k = other_index_array[j]*i32(grid_size); k < other_index_array[j]*i32(grid_size)+i32(grid_size); k++) {\n          \n          // 0は初期値なのでスキップ\n          if(gl_input[u32(k)] == 0) {\n            continue;\n          }\n          // iを算出する\n          var i = gl_input[u32(k)] - 1; // 登録の時に+1しているので-1する(配列の中で0はnullの意味で使用するため)\n\n\n\n\n        // for(var i = 0; i < num_balls; i++) {\n          // 自分自身の場合はスキップ\n          if(i == global_id.x) {\n            continue;\n          }\n\n  \n          var other_ball = input[i];\n          let n = src_ball.position - other_ball.position;\n          let distance = length(n);\n          if(distance >= src_ball.radius + other_ball.radius) {\n            // (*ef_dst).resilience_force = vec2<f32>(0,0); // 復元力を0にする\n            // 現状では終わってから同期する\n            // ef_input[ef_index_ij] = (*ef_dst);\n            continue;\n          }\n\n\n          // 接触力の相手のインデックスを保存しておく(登録時は+1しておく) \n          ef_index_output[ef_counter] = i + 1;\n          var ef_src: EF = EF(vec2<f32>(0.0, 0.0));\n          // 前の相手iに対する接触力を見つける\n          for(var l:u32 = 0; l < maxContactParticleNumber; l++) {\n            // もし1ステップ前の接触力のインデックス配列にiと同じインデックスがあれば、接触力を継承する。なければ初めて接触下として、0のままにする。\n            if(ef_index_input[global_id.x*maxContactParticleNumber + l] == i + 1){\n              ef_src.resilience_force = ef_input[global_id.x*(maxContactParticleNumber + 4 + maxLineNumber) + l].resilience_force;\n              break;\n            }\n          }\n\n\n          let other_mass = pow(other_ball.radius, 2.0) * PI * rho; // 質量;\n  \n          // eta(粘性係数)を求める\n          let eta_ij = calculationEta(m_i, other_mass);\n          // 衝突後の粒子同士の相対速度を求める\n          let u_ji = calculationVelocityAfterCollision(src_ball.position, src_ball.velocity, src_ball.anguler_velocity, src_ball.radius, other_ball.position, other_ball.velocity, other_ball.anguler_velocity, other_ball.radius);\n          // 復元力を求める\n          ef_output[ef_counter].resilience_force = calculationRestoringForceNS(ef_src.resilience_force, u_ji, k_n, k_s, TIME_STEP);\n          // 粘性力を求める\n          let viscous_force = calculationViscousForceNS(eta_ij.x, eta_ij.y, u_ji.x, u_ji.y);\n          // 弾性力を求める\n          let elastic_force_ns = calculationElasticForceNS(ef_output[ef_counter].resilience_force, viscous_force);\n          // 弾性力をxy成分に分解する\n          let elastic_force_xy = calculationElasticForceXY(elastic_force_ns, src_ball.position, other_ball.position);\n          // 合力を増加させる\n          F_i += elastic_force_xy.x;\n          G_i += elastic_force_xy.y;\n          T_i += - elastic_force_ns.y * src_ball.radius;\n  \n          // 接触相手のカウンターを一つ増やす\n          ef_counter += 1; \n        }\n      }\n\n\n      // Ball/Wall collision\n      // 左の壁\n      if((*dst_ball).position.x - (*dst_ball).radius < 0.) {\n        // 復元力のインデックスを求める(自分のインデックスの最後+1)\n        let ef_index_ij = global_id.x*(maxContactParticleNumber + 4 + maxLineNumber) + maxContactParticleNumber;\n        var ef_src = ef_input[ef_index_ij];\n\n        let alpha = 180.0; // 左なので180°\n\n        // eta(粘性係数)を求める(対壁)\n        let eta_ij = calculationEtaWithWall(m_i);\n        // 衝突後の粒子同士の相対速度を求める\n        let u_ji = calculationVelocityAfterCollisionWithWall(src_ball.velocity, src_ball.anguler_velocity, src_ball.radius, alpha);\n        // 復元力を求める\n        ef_output[maxContactParticleNumber].resilience_force = calculationRestoringForceNS(ef_src.resilience_force, u_ji, k_n, k_s, TIME_STEP);\n        // 粘性力を求める\n        let viscous_force = calculationViscousForceNS(eta_ij.x, eta_ij.y, u_ji.x, u_ji.y);\n        // 弾性力を求める\n        let elastic_force_ns = calculationElasticForceNS(ef_output[maxContactParticleNumber].resilience_force, viscous_force);\n        // 弾性力をxy成分に分解する\n        let elastic_force_xy = calculationElasticForceXYWithWall(elastic_force_ns, alpha);\n        // 合力を増加させる\n        F_i += elastic_force_xy.x;\n        G_i += elastic_force_xy.y;\n        T_i += - elastic_force_ns.y * src_ball.radius;\n\n      }else{\n\n        ef_output[maxContactParticleNumber].resilience_force = vec2<f32>(0,0); // 復元力を0にする\n\n      }\n\n      // 下の壁\n      if((*dst_ball).position.y - (*dst_ball).radius < 0.) {\n        // 復元力のインデックスを求める(自分のインデックスの最後+1)\n        let ef_index_ij = global_id.x*(maxContactParticleNumber + 4 + maxLineNumber) + maxContactParticleNumber + 1;\n        var ef_src = ef_input[ef_index_ij];\n\n\n        let alpha = 270.0; // 下なので270°\n\n        // eta(粘性係数)を求める(対壁)\n        let eta_ij = calculationEtaWithWall(m_i);\n        // 衝突後の粒子同士の相対速度を求める\n        let u_ji = calculationVelocityAfterCollisionWithWall(src_ball.velocity, src_ball.anguler_velocity, src_ball.radius, alpha);\n        // 復元力を求める\n        ef_output[maxContactParticleNumber + 1].resilience_force = calculationRestoringForceNS(ef_src.resilience_force, u_ji, k_n, k_s, TIME_STEP);\n        // 粘性力を求める\n        let viscous_force = calculationViscousForceNS(eta_ij.x, eta_ij.y, u_ji.x, u_ji.y);\n        // 弾性力を求める\n        let elastic_force_ns = calculationElasticForceNS(ef_output[maxContactParticleNumber + 1].resilience_force, viscous_force);\n        // 弾性力をxy成分に分解する\n        let elastic_force_xy = calculationElasticForceXYWithWall(elastic_force_ns, alpha);\n        // 合力を増加させる\n        F_i += elastic_force_xy.x;\n        G_i += elastic_force_xy.y;\n        T_i += - elastic_force_ns.y * src_ball.radius;\n\n\n      }else{\n\n        ef_output[maxContactParticleNumber + 1].resilience_force = vec2<f32>(0,0); // 復元力を0にする\n\n      }\n\n      // 右の壁\n      if((*dst_ball).position.x + (*dst_ball).radius >= scene.L) {\n        // 復元力のインデックスを求める(自分のインデックスの最後+1)\n        let ef_index_ij = global_id.x*(maxContactParticleNumber + 4 + maxLineNumber) + maxContactParticleNumber + 2;\n        var ef_src = ef_input[ef_index_ij];\n\n        let alpha = 0.0; // 右なので0°\n\n        // eta(粘性係数)を求める(対壁)\n        let eta_ij = calculationEtaWithWall(m_i);\n        // 衝突後の粒子同士の相対速度を求める\n        let u_ji = calculationVelocityAfterCollisionWithWall(src_ball.velocity, src_ball.anguler_velocity, src_ball.radius, alpha);\n        // 復元力を求める\n        ef_output[maxContactParticleNumber + 2].resilience_force = calculationRestoringForceNS(ef_src.resilience_force, u_ji, k_n, k_s, TIME_STEP);\n        // 粘性力を求める\n        let viscous_force = calculationViscousForceNS(eta_ij.x, eta_ij.y, u_ji.x, u_ji.y);\n        // 弾性力を求める\n        let elastic_force_ns = calculationElasticForceNS(ef_output[maxContactParticleNumber + 2].resilience_force, viscous_force);\n        // 弾性力をxy成分に分解する\n        let elastic_force_xy = calculationElasticForceXYWithWall(elastic_force_ns, alpha);\n        // 合力を増加させる\n        F_i += elastic_force_xy.x;\n        G_i += elastic_force_xy.y;\n        T_i += - elastic_force_ns.y * src_ball.radius;\n\n \n      }else{\n\n        ef_output[maxContactParticleNumber + 2].resilience_force = vec2<f32>(0,0); // 復元力を0にする\n\n      }\n\n      // 上の壁\n      if((*dst_ball).position.y + (*dst_ball).radius >= scene.L/scene.width*scene.height) {\n\n        // 復元力のインデックスを求める(自分のインデックスの最後+1)\n        let ef_index_ij = global_id.x*(maxContactParticleNumber + 4 + maxLineNumber) + maxContactParticleNumber + 3;\n        var ef_src = ef_input[ef_index_ij];\n\n        let alpha = 90.0; // 上なので90°\n\n        // eta(粘性係数)を求める(対壁)\n        let eta_ij = calculationEtaWithWall(m_i);\n        // 衝突後の粒子同士の相対速度を求める\n        let u_ji = calculationVelocityAfterCollisionWithWall(src_ball.velocity, src_ball.anguler_velocity, src_ball.radius, alpha);\n        // 復元力を求める\n        ef_output[maxContactParticleNumber + 3].resilience_force = calculationRestoringForceNS(ef_src.resilience_force, u_ji, k_n, k_s, TIME_STEP);\n        // 粘性力を求める\n        let viscous_force = calculationViscousForceNS(eta_ij.x, eta_ij.y, u_ji.x, u_ji.y);\n        // 弾性力を求める\n        let elastic_force_ns = calculationElasticForceNS(ef_output[maxContactParticleNumber + 3].resilience_force, viscous_force);\n        // 弾性力をxy成分に分解する\n        let elastic_force_xy = calculationElasticForceXYWithWall(elastic_force_ns, alpha);\n        // 合力を増加させる\n        F_i += elastic_force_xy.x;\n        G_i += elastic_force_xy.y;\n        T_i += - elastic_force_ns.y * src_ball.radius;\n\n      }else{\n\n        ef_output[maxContactParticleNumber + 3].resilience_force = vec2<f32>(0,0); // 復元力を0にする\n\n      }\n\n\n      // 線分要素の計算\n      // 線分でループする\n      for(var l = 0u; l < maxLineNumber; l = l + 1u) {\n        // 線分が有効でないときは次のループへ\n        if(line_input[l].isValid == 0u){\n          continue;\n        }\n        let AC = calVectorAC(line_input[l], src_ball.position);\n        let tdash = calTDash(line_input[l], AC);\n        let D = calVectorD(line_input[l], tdash);\n        // 接触判定              \n        let distance = length(src_ball.position - D);\n        // 接触しないとき\n        if(distance >= src_ball.radius + line_input[l].thickness) {\n          ef_output[maxContactParticleNumber + 4 + l].resilience_force = vec2<f32>(0,0); // 復元力を0にする\n          continue;\n        }\n        // 復元力のインデックスを求める(自分のインデックスの最後+1)\n        let ef_index_ij = global_id.x*(maxContactParticleNumber + 4 + maxLineNumber) + maxContactParticleNumber + 4 + l;\n        var ef_src = ef_input[ef_index_ij];\n\n\n        // eta(粘性係数)を求める\n        let eta_ij = calculationEtaWithWall(m_i);\n        // 衝突後の粒子同士の相対速度を求める\n        let u_ji = calculationVelocityAfterCollisionWithStackLine(src_ball.position, src_ball.velocity, src_ball.anguler_velocity, src_ball.radius, D, vec2<f32>(0,0), 0, line_input[l].thickness);\n        // 復元力を求める\n        ef_output[maxContactParticleNumber + 4 + l].resilience_force = calculationRestoringForceNS(ef_src.resilience_force, u_ji, k_n, k_s, TIME_STEP);\n        // 粘性力を求める\n        let viscous_force = calculationViscousForceNS(eta_ij.x, eta_ij.y, u_ji.x, u_ji.y);\n        // 弾性力を求める\n        let elastic_force_ns = calculationElasticForceNS(ef_output[maxContactParticleNumber + 4 + l].resilience_force, viscous_force);\n        // 弾性力をxy成分に分解する\n        let elastic_force_xy = calculationElasticForceXY(elastic_force_ns, src_ball.position, D);\n        // 合力を増加させる\n        F_i += elastic_force_xy.x;\n        G_i += elastic_force_xy.y;\n        T_i += - elastic_force_ns.y * src_ball.radius;\n\n\n      }\n\n\n      // END 線分要素の計算\n\n\n      // 粒子の加速度を求める\n      let acceleration = calculationAcceleration(m_i, F_i, G_i);\n      // 粒子の速度を求める\n      (*dst_ball).velocity = calculationVelocity(src_ball.velocity, acceleration, TIME_STEP);\n      // 粒子の位置を求める\n      (*dst_ball).position = calculationPosition(src_ball.position, (*dst_ball).velocity, TIME_STEP);\n      // 粒子の角加速度を求める\n      let angular_acceleration = calculationAngularAcceleration(I_i, T_i);\n      // 粒子の角速度を求める\n      (*dst_ball).anguler_velocity = calculationAngularVelocity(src_ball.anguler_velocity, angular_acceleration, TIME_STEP);\n      // 粒子の角度を求める\n      (*dst_ball).angle = calculationAngle(src_ball.angle, (*dst_ball).anguler_velocity, TIME_STEP);\n\n\n      // 異なるworkgroup間では現在同期できないのでforloopは使えない\n\n      let gl_index:u32 = u32(floor((*dst_ball).position.y/spacing))*nx + u32(floor((*dst_ball).position.x/spacing));\n\n      var c = atomicAdd(&gl_atomic[gl_index], u32(1));//加算(各関数は次の手順をアトミックに実行します。\n      // 1.atomic_ptrが指す元の値をロードします, \n      // 2.値vを使用して関数名から演算 (例: max) を実行することにより、新しい値を取得します。\n      // 3.atomic_ptrを使用して新しい値を保存します。\n      // 各関数は、アトミック オブジェクトに格納されている元の値を返します。)\n\n      gl_output[gl_index*grid_size+c] = global_id.x+1; // 初期化で0にしているのでindex=0と初期化がかぶらないように+1する\n\n      \n      // 接触力を次のループのために保存する\n      for(var l:u32 = 0; l < maxContactParticleNumber; l++) {\n          // 接触力を代入する\n          ef_input[global_id.x*(maxContactParticleNumber + 4 + maxLineNumber) + l] = ef_output[l];\n          // 接触力のインデックスを代入する\n          ef_index_input[global_id.x*maxContactParticleNumber + l] =  ef_index_output[l];\n      }\n      // 壁の分\n      ef_input[global_id.x*(maxContactParticleNumber + 4 + maxLineNumber) + maxContactParticleNumber]     = ef_output[maxContactParticleNumber];\n      ef_input[global_id.x*(maxContactParticleNumber + 4 + maxLineNumber) + maxContactParticleNumber + 1] = ef_output[maxContactParticleNumber + 1];\n      ef_input[global_id.x*(maxContactParticleNumber + 4 + maxLineNumber) + maxContactParticleNumber + 2] = ef_output[maxContactParticleNumber + 2];\n      ef_input[global_id.x*(maxContactParticleNumber + 4 + maxLineNumber) + maxContactParticleNumber + 3] = ef_output[maxContactParticleNumber + 3];\n\n      // 線分の分\n      for(var l:u32 = 0; l < maxLineNumber; l++) {\n          // 接触力を代入する\n          ef_input[global_id.x*(maxContactParticleNumber + 4 + maxLineNumber) + maxContactParticleNumber + 4 + l] = ef_output[maxContactParticleNumber + 4 + l];\n      }\n    }\n  ")}),ae=u.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:4,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:5,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:6,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:7,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]}),oe=u.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]}),le=u.createComputePipeline({layout:u.createPipelineLayout({bindGroupLayouts:[ae,oe]}),compute:{module:re,entryPoint:"main"}}),ce=u.createBuffer({size:16*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),ue=u.createBuffer({size:j,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),se=u.createBuffer({size:j,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.VERTEX}),fe=u.createBuffer({size:G,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),_e=u.createBuffer({size:A,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),de=u.createBuffer({size:N,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),pe=u.createBuffer({size:N,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST}),ye=u.createBuffer({size:L,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST}),ve=u.createBuffer({size:x,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),xe=u.createBuffer({size:x,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST}),ge=u.createBindGroup({layout:ae,entries:[{binding:0,resource:{buffer:ue}},{binding:1,resource:{buffer:se}},{binding:2,resource:{buffer:fe}},{binding:3,resource:{buffer:ce}},{binding:4,resource:{buffer:de}},{binding:5,resource:{buffer:pe}},{binding:6,resource:{buffer:ye}},{binding:7,resource:{buffer:_e}}]}),me=u.createBindGroup({layout:oe,entries:[{binding:0,resource:{buffer:ve}},{binding:1,resource:{buffer:xe}}]}),he=u.createShaderModule({label:"Cell shader",code:"\n    // Your shader code will go here\n\n    struct Ball {\n      radius: f32,\n      padding: f32,\n      position: vec2<f32>,\n      velocity: vec2<f32>,\n      angle: f32,\n      anguler_velocity: f32,\n    }\n    @group(0) @binding(0)\n    var<storage, read> output: array<Ball>;\n\n    struct VertexOutput {\n      @builtin(position) pos: vec4f,\n      @location(0) cellColor: vec4f, // New line!\n    };\n\n    struct Scene {\n      width: f32, // canvasの幅(pixel)\n      height: f32, // canvasの高さ(pixel)\n      L: f32, // canvasの幅(m)\n      fps: f32, // フレームレート\n      minRadius: f32, // 粒子の最小半径(m)\n      maxRadius: f32, // 粒子の最大半径(m)\n      nx: f32, // x方向の格子点数\n      grid_size: f32, // 1グリッドあたりの最大要素数\n      spacing: f32, // 格子間隔\n      numBalls: f32, // 粒子数\n      maxContactParticleNumber: f32, // 最大接触粒子数\n      offsetX: f32,               // カメラ中心 X\n      offsetY: f32,               // カメラ中心 Y\n      zoomValue: f32, // ズーム係数\n      colorMode: f32, // カラーモード\n    }\n\n    @group(0) @binding(1)\n    var<uniform> scene: Scene;\n\n    // 頂点シェーダーを定義する\n    @vertex\n    fn vertexMain(@builtin(vertex_index) vertex_index : u32, @builtin(instance_index) instance_index: u32, @location(0) pos: vec2<f32>) ->\n    VertexOutput {\n      var vertexOutput: VertexOutput;\n      let widthByL: f32 = scene.width/scene.L; \n      \n      // パーティクル中心 (ピクセル座標)(左下基準)\n      let cx = output[instance_index].position.x * widthByL;\n      let cy = output[instance_index].position.y * widthByL;\n      \n      // 回転\n      let rx = cos(radians(output[instance_index].angle)) * pos.x\n            - sin(radians(output[instance_index].angle)) * pos.y;\n      let ry = sin(radians(output[instance_index].angle)) * pos.x\n            + cos(radians(output[instance_index].angle)) * pos.y;\n\n      // 中心オフセット+NDC変換\n      // offsetX, offsetY はピクセル単位\n      let ndcX = ((cx - scene.offsetX )  + rx * output[instance_index].radius * widthByL)\n                / scene.width * 2.0 * scene.zoomValue - 1.0;\n      let ndcY = ((cy - scene.offsetY )  + ry * output[instance_index].radius * widthByL)\n                / scene.height * 2.0 * scene.zoomValue - 1.0;\n\n      // ズーム係数を適用\n      vertexOutput.pos = vec4f(ndcX, ndcY, 0.0, 1.0);\n\n      // 粒子番号の場合\n      if(u32(scene.colorMode) == 0){\n        if(instance_index < u32(0.25*scene.numBalls)){\n          // vertexOutput.cell = 0.25;\n          vertexOutput.cellColor = vec4f(0.25, 0, 1.0, 1);\n        }else if(instance_index < u32(0.5*scene.numBalls)){\n          vertexOutput.cellColor = vec4f(0.5, 0, 1.0, 1);\n        }else if(instance_index < u32(0.75*scene.numBalls)){\n          vertexOutput.cellColor = vec4f(0.75, 0, 1.0, 1);\n        }else{\n          vertexOutput.cellColor = vec4f(1.0, 0, 1.0, 1);\n        }\n      }else if(u32(scene.colorMode) == 1){\n        let velocity = length(output[instance_index].velocity);\n        vertexOutput.cellColor = vec4f(velocity, 0, 100, 1);\n      }\n\n      return vertexOutput; // (X, Y, Z, W) w の値は、3 次元同次座標系における頂点の 4 つ目の要素,3D グラフィックのレンダリングでよく行われる 4x4 行列を使用した計算が可能になる\n    }\n\n    // フラグメント シェーダーを定義する(戻り値は0～1)\n    @fragment\n    fn fragmentMain(input: VertexOutput) -> @location(0) vec4f {\n\n      return input.cellColor; // (Red, Green, Blue, Alpha)\n    }   \n  "}),Pe=be(0,0,1,10),je=u.createBuffer({label:"Cell vertices",size:Pe.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.VERTEX}),u.queue.writeBuffer(je,0,Pe),Ee={arrayStride:8,attributes:[{format:"float32x2",offset:0,shaderLocation:0}]},we=u.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.VERTEX,buffer:{type:"read-only-storage"}},{binding:1,visibility:GPUShaderStage.VERTEX,buffer:{type:"uniform"}}]}),Be=u.createBindGroup({label:"Cell renderer bind group",layout:we,entries:[{binding:0,resource:{buffer:se}},{binding:1,resource:{buffer:ce}}]}),Se=u.createPipelineLayout({label:"Cell Pipeline Layout",bindGroupLayouts:[we]}),Ce=u.createRenderPipeline({label:"Cell pipeline",layout:Se,vertex:{module:he,entryPoint:"vertexMain",buffers:[Ee]},fragment:{module:he,entryPoint:"fragmentMain",targets:[{format:te}]}}),Ne=u.createShaderModule({label:"Line shader",code:"\n      struct Line {\n        thickness: f32,\n        isValid: u32,\n        position_1: vec2<f32>,\n        position_2: vec2<f32>,\n        velocity: vec2<f32>,\n        angle: f32,\n        anguler_velocity: f32,\n      }\n      \n      @group(0) @binding(0)\n      var<storage, read> line_output: array<Line>;\n      \n      struct Scene {\n        width: f32, height: f32, L: f32, fps: f32,\n        minRadius: f32, maxRadius: f32, nx: f32, grid_size: f32,\n        spacing: f32, numBalls: u32, maxContactParticleNumber: f32,\n        offsetX: f32, offsetY: f32, zoomValue: f32, colorMode: f32,\n      }\n      \n      @group(0) @binding(1)\n      var<uniform> scene: Scene;\n      \n      struct VertexOutput {\n        @builtin(position) pos: vec4f,\n        @location(0) color: vec4f,\n      };\n      \n      @vertex\n      fn vertexMain(@location(0) pos: vec2<f32>, @builtin(vertex_index) vertexIndex: u32) -> VertexOutput {\n        var output: VertexOutput;\n        let widthByL: f32 = scene.width/scene.L;\n        \n        // 座標を決定（0と1のインデックスで線分の両端を取得）\n        let lineIndex = vertexIndex / 2;\n        let pointIndex = vertexIndex % 2;\n        \n              \n        // isValidをチェック\n        let isVisible: bool = line_output[lineIndex].isValid != 0u;\n\n        // select(falseの場合の値, trueの場合の値, 条件式)\n        // 線分は常に2つの頂点（始点と終点）から構成されます\n        // pointIndexは処理中の頂点が線分のどちら側かを示します（0か1）\n        // GPUでは条件分岐（if文）を避けて、このselectのような関数を使うことでパフォーマンスが向上します\n        let position = select(\n          line_output[lineIndex].position_1,\n          line_output[lineIndex].position_2,\n          pointIndex == 1\n        );\n        \n        // NDC座標に変換\n        let ndcX = ((position.x * widthByL) - scene.offsetX) \n                  / scene.width * 2.0 * scene.zoomValue - 1.0;\n        let ndcY = ((position.y * widthByL) - scene.offsetY) \n                  / scene.height * 2.0 * scene.zoomValue - 1.0;\n        \n        // isValid が 0 の場合は線分を画面外に配置（実質的に非表示にする）\n        if (isVisible) {\n          output.pos = vec4f(ndcX, ndcY, 0.0, 1.0);\n          output.color = vec4f(1.0, 0.5, 0.0, 1.0); // オレンジ色\n        } else {\n          // 画面外に配置（クリッピングされる）\n          output.pos = vec4f(0.0, 0.0, 10.0, 0.0); \n          output.color = vec4f(0.0, 0.0, 0.0, 0.0); // 透明\n        }\n        \n        return output;\n      }\n      \n      @fragment\n      fn fragmentMain(input: VertexOutput) -> @location(0) vec4f {\n        return input.color;\n      }\n    "}),Le={arrayStride:8,attributes:[{format:"float32x2",offset:0,shaderLocation:0}]},Te=new Float32Array([0,0,0,0]),Ue=u.createBuffer({label:"Line vertices",size:Te.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST}),u.queue.writeBuffer(Ue,0,Te),Ge=u.createBindGroup({label:"Line renderer bind group",layout:we,entries:[{binding:0,resource:{buffer:xe}},{binding:1,resource:{buffer:ce}}]}),Ae=u.createRenderPipeline({label:"Line pipeline",layout:Se,vertex:{module:Ne,entryPoint:"vertexMain",buffers:[Le]},fragment:{module:Ne,entryPoint:"fragmentMain",targets:[{format:te}]},primitive:{topology:"line-list",stripIndexFormat:void 0}}),Fe(),ke=z.getContext("2d"),z.width=f,z.height=_,z.style.width=f+"px",z.style.height=_+"px",q.addEventListener("change",function(){return Ve("id")}),X.addEventListener("change",function(){return Ve("vabs")}),s.addEventListener("mousedown",function(e){V=!0,s.style.cursor="grabbing";var n=s.getBoundingClientRect();R=e.clientX-n.left,Y=e.clientY-n.top}),s.addEventListener("mousemove",function(e){if(V){var n=s.getBoundingClientRect(),t=e.clientX-n.left,i=e.clientY-n.top;M-=(t-R)/k,F+=(i-Y)/k,R=t,Y=i,Re()}}),s.addEventListener("mouseup",function(){V=!1,s.style.cursor="grab"}),s.addEventListener("wheel",function(e){e.preventDefault();var n=s.getBoundingClientRect(),t=e.clientX-n.left,i=e.clientY-n.top,r=k;e.deltaY<0?k*=1.1:k/=1.1;var a=(k=Math.max(.1,Math.min(k,12)))/r;M=t-1/a*(t-M),F=d.canvas.height-i-1/a*(d.canvas.height-i-F),Re()}),W.addEventListener("change",function(){u.queue.writeBuffer(ve,0,ne()),u.queue.writeBuffer(xe,0,ne()),Re()}),Ye=0,We=void 0,ze=1/O*1e3,D.addEventListener("click",De,!1),Z.addEventListener("click",He,!1),H.addEventListener("click",Ze,!1),J.addEventListener("click",Je,!1);case 142:case"end":return e.stop()}},e)}))();
},{}]},{},["epB2"], null)
//# sourceMappingURL=main.f162dfa5.js.map